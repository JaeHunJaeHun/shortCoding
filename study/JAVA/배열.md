# 배열
## 배열이란
같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 '배열(Array)'라고 한다.   
여기서 중요한 것은 '같은 타입'이어야 한다는 것이며, 서로 다른 타입의 변수들로 구성된   
배열은 만들 수 없다.
- 한 학급의 시험점수를 저장하고자 할 때가 배열을 사용하기 좋은 예이다.
```java
int score1, score2, score3, score4, score5; // 배열을 사용하지 않는다면
```
```java
int[] score = new int[5]; // 5개의 int 값을 저장할 수 있는 배열을 생성한다.
```
변수 score은 배열을 다루는데 필요한 참조변수일 뿐 값을 저장하기 위한 공간은 아니다.

## 배열의 선언과 생성
```java
타입[] 변수이름;            // 배열을 선언 (배열을 다루기 위한 참조변수 선언
int[] score;
변수이름 = new 타입[길이];  // 배열을 생성 (실제 저장공간을 생성)
int[] score = new int[5];
```
1. int[] score;
int형 배열 참조변수 score를 선언한다. 데이터를 저장할 수 있는 공간은 아직 마련되지 않았다.
2. socre = new int[5];
연산자 new 에 의해서 메모리의 빈 공간에 5개의 int형 데이터를 저장할 수 있는 공간이 마련된다.
3. 그리고 각 배열 요소들은 자동으로 int의 기본값인 0으로 초기화된다.
4. 끝으로 대입 연산자 = 에 의해 배열의 주소가 int 형 배열 참조변수 score에 저장된다.

## 배열의 길이와 인덱스
생성된 배열의 각 저장공간을 '배열의 요소(element)'라고 하며, 배열이름[인덱스] 형식으로 배열의 요소에 접근한다.
```
"인덱스 (index)의 범위는 0부터 '배열길이-1 까지'"
```
예를 들어 길이가 5인 배열은 모두 5개의 요소(저장공간)을 가지며 인덱스의 범위는 0 ~ 4가 된다.
```java
int[] socre = new int[5];
score[3] = 100;           // 배열 score의 4번째 요소에 100을 저장한다.
int value = score[3];     // 배열 score의 4번째 저장된 값을 읽어서 value에 저장
```
배열의 또 다른 장점은 index로 상수 대신 변수나 수식도 사용할 수 있다는 것이다.   
```java
score[0] = 0;
score[1] = 10;
score[2] = 20;
score[3] = 30;
score[4] = 40;
->
for (int i = 0; i < 5; i++){
    score[i] = i * 10;
}
```
배열을 다룰 때 한 가지 주의할 점은 index의 범위를 벗어난 값을 index로 사용하지 않아야 한다는 것이다.   
유효하지 않은 값을 index로 사용하면 실행 시 에러(ArrayIndexOutOfBoundException)가 발생한다.
```java
int[] a = new int[5];
int i = a[6]; // 에러
```
## 배열의 크기
```java
타입[] 배열이름 = new 타입[길이];
int[] arr = new int[5]; //길이가 5인 배열

int[] arr2 = new int[0] // 길이가 0인 배열도 생성이 가능하다!
```
길이가 0인 배열이 필요한 상황이 있고 나름 유용하다. 배열의 길이는 int 범위의 양의 정수(0도 포함)이어야 한다.

## 배열이름.length
자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.
```java
int[] arr = new int[5];   // 길이가 5인 int배열
int temp = arr.length;    // arr.length의 값은 5이고 tmp에 5가 저장된다.
```
배열이름.length 는 상수이다. 값 변경이 불가능하다.

## 배열의 길이 변경하기
1. 더 큰 배열을 새로 생성한다.
2. 기존 배열의 내용을 새로운 내용에 복사한다.
이러한 작업들은 꽤나 비용이 들기 때문에 처음부터 배열의 길이를 넉넉하게 잡아줘서 새로운 배열을 생성하는 상황이 가능한 적게 발생
해야한다. 그렇다고 배열의 길이를 너무 크게 잡으면 메모리를 낭비하게 되므로, 기존의 2배정도의 길이를 생성하는 것이 좋다.

## 배열의 초기화
배열은 생성과 동시에 자동으로 자신의 타입에 해당하는 기본값으로 초기화되므로 배열을 사용하기 전까지 초기화 해주지 않아도 된다.
```java
int[] score = new int[5];
score[0] = 50; // 각 요소의 값을 직접 저장
score[1] = 60;
score[2] = 70;
score[3] = 80;
score[4] = 90;

->

int[] score = new int[5];

for(int i=0; i < score.length; i++)
     score[i] = i * 10 + 5;

int[] score = new int[]{50, 60, 70, 80, 90}; // 배열 생성과 초기화를 동시에
->
int[] score = {50, 60, 70, 80, 90}; // new int[]  생략가능, but 배열의 선언과 생성을 따로 하는 경우 사용이 불가능 하다.
```

## 배열의 출력
```java
int[] arr = {100, 95, 80, 70, 60};

// 배열의 요소를 순서대로 하나씩 출력
for (int i=0; i < arr.length; i++){
    System.out.print(arr[i]);
}

System.out.print(Arrays.toString(arr));
System.out.print(arr); // 타입@주소

char[] chArr = {'a','b','c','d'};
System.out.print(chArr); // abcd가 출력된다.(println 메서드가 char 배열일 때 이렇게 동작하도록 작성되어 있기 때문이다.)
```

## 배열의 복사
배열을 복사하는 방법은 두가지가 있다. 먼저 for문을 이요해서 배열을 복사하는 방법은 다음과 같다.
```java
int[] arr = new int[5];

int[] tmp = new int[arr.length * 2]; // 기존 배열보다 길이가 2배인 배열 생성

for(int i =0; i < arr.length; i++)
    temp[i] = arr[i]; // arr[i]값을 temp[i]에 저장
    
arr = temp; // 참조변수 arr이 새로운 배열을 가리키게 한다.
```

### System.arrayCopy()를 이용한 배열의 복사   
배열의 복사는 for문보다 System.arraycopy()를 사용하는 것이 효율적이다.
```java
System.arraycopy(num, 0, newNum, 0, num.length);
// num[0]에서 newNum[0]으로 num.length개의 데이터 복사
```
이때 복사하려는 배열의 위치가 적절하지 못하여 복사하려는 내용보다 여유공간이 적으면 에러가 발생한다.


































