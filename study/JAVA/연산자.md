# 연산자
연산자란 '연산을 수행하는 기호'를 말한다.

## 연산자와 피연산자
```
연산자 (operator) : 연산을 수행하는 기호 (+,-,*,/ 등)
피연산자 (operand) : 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)
```

## 식과 대입연산자
```java
4 * x + 3; // 이 값은 어디에도 사용되지 않고 사라진다.

y = 4 * 5 + 3; // 대입연산자 '='를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야한다.
```

### 연산자의 종류
- 산술 연산자 : +  -  *  /  %  <<  >>     사칙연산 + 나머지연산
- 비교 연산자 : >  <  >=  <== == !=       크고 작음과 같고 다름을 비교
- 논리 연산자 : &&  ||  !  &  |  ^  ~     그리고와 또는 으로 조건 연결
- 대입 연산자 :         =                 우변의 값을 좌변에 저장
- 기      타 : (type) ? : instanceof     형변환 연산자, 삼항 연산자, instanceof연산자

### 연산자의 우선순위와 결합규칙
```java
1. -x + 3                // 단항연산자, 이항연산자

2. x + 3 * y

3. x + 3 > y - 2        // 비교연산자, 산술연산자

4. x > 3 && x < 5       // 논리연산자, 비교연산자

5. result = x + y * 3;  // 대입연산자

6. x << 2 + 1           // 쉬프트 연산자, 덧셈연산자

7. data & 0xFF == 0         // 비트연산자, 비교연산자

8. x < -1 || x > 3 && x < 5 // 논리연산자 &, && -> |, ||
```
* 하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 연산을 수행하는 규칙을 "연산자의 결합규칙" 이라고 한다.
1. 산술 > 비교 > 논리 > 대입
2. 단항(1) > 이항(2) > 삼항(3) 단항 연산자의 우선순위가 이항 연산자 보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽이다.
   
☆ 연산자와 우선순위와 결합규칙 -> 검색

## 산술 변환
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능 하므로, 피 연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로
타입을 일치 시켜야 한다.
```java
int i = 10;
float f = 20.of;

float result = f + (fluat)i; // 형변환으로 두 피연산자의 타입을 일치
```
대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될
가능성이 있기 떄문이다.   
작은 타입에서 큰 타임으로 형변환하는 경우, 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.
```java
float result = f + i; // 큰 타입으로 형 변환시, 형변환 연산자 생략 가능
```
이처럼 자동으로 형변환 되는 것을 '산술 연산' 또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산자에서만 아니라 단항 연산자에서도 일어난다.
- 산술 변화의 규칙
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
```java
long + int -> long + long

float + int -> float + float

double + float -> double + double
```
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```java
byte + short -> int + int

char + short -> int + int
```
- 첫번쨰 규칙은 피연산자의 값손실을 최소화 하기위한 것
- 두번쨰 규칙은 정수타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문에, char 이나 short의 표현 범위가 좁아서
  연산중에 오버플로우가 발생할 가능성이 높기 떄문에 만들어진 것이다.
☆ 연산결과의 타입은 피연산자의 타입과 일치한다.
```java
5 / 2 = 2 // 소숫점은 버려짐
```
```
산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```

## 단항 연산자
```
증감 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.
```
* 증감연산자는 일반 산술 변환에 의한 자동 형변환이 방생하지 않으며, 연산결과의 타입은 피연산 결과의 타입과 같다.
피연산자의 왼쪽에 위치하면 '전위형(prefix)', 오른쪽에 위치하면 '후위형(postfix)'라고 한다.
```
int i = 5, j = 0;
        
j = i++;
        
i = 5; 
j = 0;
        
j = ++i;
```
증감연산자를 사용하면 코드가 간결해지지만, 지나치면 코드가 복잡해져 이해하기 어려워지기도 한다.
식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야한다.   
```java
x = x++ - ++x  // 식이 너무 복잡함
```
감소연산자(--)는 피연산자의 값을 1 감소시킨다는 것만 뺴면 증가 연산자와 동일하다.

## 부호연산자 (+ , -)
부호연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다.   
부호연산자 '+'는 하는 일이 없으며, 쓰이는 경우도 거의 없다. 부호연산자 '-'가 있으니까   
형식적으로 '+'를 추가해 놓은 것뿐이다.
```java
int i = -10;
i = +i;
        
i = -10;
i = -i;
```

## 산술연산자 (+, -, *, /, %)

우선순위
```
* -> / -> % -> + -> -
```
피연산자가 정수형인 경우 0으로 나눈다면 실행 시 에러가 발생
```java
System.out.print(3/0);  // 실행 시, 오류(ArithmeticException) 발생
System.out.print(3/0.0); // Infinity 출력
```
```java
byte a = 10;
byte b = 20;
byte c = a + b; // 컴파일 에러 발생 명시적 형변환이 필요 (byte)(a+b);
```

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다. 문제는 실제로 해당 문자의 유니코드(부호없는 정수)   
로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다. 주로 문자간의 뺄셈을 하는 경우가 대부분이며,   
문자 '2'를 숫자로 변환하려면 다음과 같이 문자 '0'을 뺴주면 된다.
```java
'2' - '0' -> 50 - 48 -> 2
```
| 문자 | 코드 |
|------|------|
|0|48|
|9|57|
|A|65|
|Z|90|
|a|97|
|z|122|
```java
char c1 = 'a';    // c1에는 문자 'a'의 코드값인 97이 저잔된다.
char c2 = c1;     // c1에 저장되어 있는 값이 c2에 저장된다.
char c3 = ' ';    // c3를 공백으로 초기화한다. 참고로 공백은 32 !

int i = c1 + 1 ;  // 97 + 1 = 98
c3 = (char) (c1 + 1) // 'b'
```

```java
char c1 = 'a';          
// char c2 = c1 + 1;       // 컴파일 에러 발생
char c2 = 'a' + 1;      // 컴파일 에러 없음 ?? 왜 에러가 안나는 것일까
System.out.print(c2);   // b
```

'a'+1이 리터럴 간의 연산이기 떄문이다. 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에,   
컴파일 시 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. -> 실행 시에는 이미 결과가 들어가 있다
- 컴파일 전의 코드
```java
char c2 = 'a' + 1;
int sec = 60 * 60 * 24;
```
- 컴파일 후의 코드
```java
char c2 = 'b';
int sec = 96400;
```

## 나머지 연산자 %
나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다.   
오른쪽 연산자로 0을 사용할 수 없다.
```java
System.out.print(-10%8);   // -2
System.out.print(10%-8);   // 2
System.out.print(-10%-8);  // -2
```
피연산자의 부호는 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자의 부호를 붙이면 된다.

## 비교 연산자
두 피연산자를 비교하는데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 오직   
true와 false 둘 중 하나이다.   
이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환되어   
피연산자의 타입을 일치시킨 후에 비교한다.

## 대소비교 연산자 > < >= <=
|비교연산자|연산결과|
|----------|--------|
|>|좌변 값이 크면, true or false|
|<|좌변 값이 작으면, true or false|
|>=|좌변 값이 크거나 같으면, true or false|
|<=|좌변 값이 작거나 같으면, true or false|
















